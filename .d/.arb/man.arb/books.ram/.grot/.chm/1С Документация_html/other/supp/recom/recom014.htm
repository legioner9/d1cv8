<html>
<head>
<title>1С-Предприятие. Документация | Технологические вопросы</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" type="text/css" href="../../../1c.css">
<style type="text/css">
<!--
h1 {  font-size: 16pt; font-weight: bold}
h2 { font-size: 14pt; font-weight: bold }
h3 { font-size: 12pt; font-weight: bold }
h4 { font-size: 10pt; font-weight: bold }
-->
</style>
</head>
<body background="../../../images/background_main.gif">
<h1 align="left">Технологические вопросы</h1>
<hr>
<ul>
  <li><a href="#_toc503983476"><b>Обработка ошибочных 
    ситуаций во встроенном языке системы 1С:Предприятие  7.7</b></a></li>
  <li><b><a href="#_toc503983477">Блокировка объектов 
    базы данных</a></b></li>
  <li><b><a href="#_toc503983478">Вычисление логических 
    выражений в операторах встроенного языка</a></b></li>
  <li><b><a href="#_toc503983480">Особенности применения 
    предопределенных процедур встроенного языка</a></b></li>
  <li><b><a href="#_toc503983482">Сохранение (восстановление) 
    значений в строку</a></b></li>
  <li><b><a href="#_toc503983483">Работа со значениями 
    агрегатных типов во встроенном языке</a></b></li>
  <li><b><a href="#_toc503983484">Значения типов, соответствующих 
    объектам и информационной базы во встроенном языке</a></b></li>
  <li><b><a href="#_toc503983486">Выбор разрядности для 
    данных числовых типов</a></b></li>
  <li><b><a href="#_toc503983487">Перебор объектов и 
    групповое изменение данных</a></b></li>
  <li><b><a href="#_toc503983488">Ошибки базы данных 
    и их обработка</a></b></li>
  <li><b><a href="#_toc503983489">Использование строковых 
    реквизитов неограниченной длины</a></b></li>
  <li><b><a href="#_toc503983490">Особенности работы 
    с типизированными и не типизированными колонками таблицы значений.</a></b></li>
  <li><b><a href="#_toc503983491">Применение процедуры 
    ПриНачалеРаботыСистемы() глобального модуля</a></b></li>
  <li><b><a href="#_toc503983493">Точность вычисления 
    и представления числовых величин</a></b></li>
  <li><b><a href="#_toc503983494">Доступ во встроенном 
    языке к метаданным</a></b></li>
  <li><b><a href="#_toc503983495">Особенности работы 
    с реквизитами неопределенного типа</a></b></li>
  <li><b><a href="#_toc503983496">Особенности написания 
    тела модуля</a></b></li>
</ul>
<h2><a name="_Toc503983476">Обработка ошибочных ситуаций во встроенном языке системы 
  1С:Предприятие  7.7</a></h2>
<p>Во встроенный язык системы 1С:Предприятие 7.7 внесена возможность обработки 
  ошибочных ситуаций. В предыдущих версиях системы 1С:Предприятие любая ошибка, 
  происшедшая при выполнении модулей встроенного языка приводила к завершению 
  выполнения модуля и выдаче в окно сообщений информации о характере ошибки и 
  модуле, в котором она произошла. При этом разработчик конфигурации не имел возможности 
  вмешаться в процесс обработки ошибочной ситуации и предусмотреть некоторые действия, 
  которые могут нейтрализовать последствия ошибки и позволить продолжить выполнение 
  модуля. Особенно неприятны ситуации, когда из-за несущественных поводов прекращается 
  выполнение длительных процедур, после чего их приходилось начинать сначала. 
  Примером такой ситуации может послужить обработка, выполняющая обход и обновление 
  некоторого реквизита большого числа элементов справочника в случае, если в процессе 
  работы будет произведена попытка обновить реквизит заблокированный другим пользователем. 
  Неприятны также ситуации, когда конфигурации, использующие внешние по отношению 
  к системе 1С:Предприятие программные средства через механизмы OLE Automation 
  не могли произвести проверку наличия установленных на компьютере пользователя 
  необходимых программных средств. Примером для такого случая может послужить 
  поведение отчета, выводящего результаты через OLE Automation в таблицу MS Excel, 
  в условиях, когда MS Excel на компьютере пользователя отсутствует.</p>
<p>С появлением системы 1С:Предприятие 7.7 положение дел изменилось. Теперь разработчики 
  конфигураций могут предусматривать в алгоритмах модулей реакцию на все ошибочные 
  ситуации, которые могут возникать при выполнении модулей встроенного языка. 
  В целом средства обработки ошибочных (исключительных) ситуаций подобны аналогичным 
  средствам предусмотренным в современных языках программирования.</p>
<p>Попытка</p>
<p>    // Некоторые действия</p>
<p>Исключение</p>
<p>    // Обработка исключительной (ошибочной) ситуации)</p>
<p>КонецПопытки</p>
<p>Суть в следующем: если при выполнении последовательности операторов &lt;// 
  Некоторые действия&gt; происходит ошибка, то выполнение оператора прекращается 
  и управление передается на первый оператор последовательности &lt;// Обработка 
  исключительной (ошибочной) ситуации)&gt;. После завершения выполнения данной 
  последовательности управление получает первый оператор, следующий за КонецПопытки. 
  В случае, если при выполнении &lt;// Некоторые действия&gt; ошибок не произошло, 
  то управление, минуя &lt;// Обработка исключительной (ошибочной) ситуации)&gt; 
  также попадает на первый оператор, следующий за КонецПопытки. Конструкции Попытка…Иключение…КонецПопытки 
  могут быть вложенными, при этом для передачи управления из более внутреннего 
  обработчика исключительной ситуации в более внешний служит оператор ВызватьИсключение. 
  В случае, если оператор ВызватьИсключение будет выполнен в самом внешнем обработчике 
  ошибки, то выполнение модуля будет прекращено и сообщение об ошибке будет выдано 
  в окно сообщений, как и в случае полного отсутствия обработчиков ошибок. Для 
  получения текста описания ошибки внутри последовательности операторов &lt;// 
  Обработка исключительной (ошибочной) ситуации)&gt; служит встроенная функция 
  ОписаниеОшибки(). Более подробно о механизме обработки исключительных ситуаций 
  можно прочитать в книге &quot;1С:Предприятие 7.7. Описание встроенного языка. 
  Часть 1.&quot;.</p>
<p>В методической конфигурации приводится обработка ПересчетЦен, модуль которой 
  содержит пример обработки ошибочной ситуации. Данная обработка изменяет значение 
  реквизита Цена для всех элементов справочника Товары путем умножения на вводимый 
  пользователем коэффициент. Предполагается, что справочник Товары может содержать 
  несколько тысяч элементов. При этом значения реквизита для всех элементов должны 
  быть изменены согласованно, не прерывая работы других пользователей. Для обеспечения 
  согласованности изменения реквизитов всех элементов справочника все изменения 
  выполняются в рамках одной транзакции.</p>
<p>Если в процессе записи какого-либо элемента справочника Товары произойдет ошибка, 
  то управление будет передано в блок обработки исключительных ситуаций. Пользователю 
  будет выдано сообщение об ошибке и запрос на повторение попытки записи элемента 
  справочника. Если пользователь, выберет вариант &quot;Да&quot;, то попытка записи 
  будет повторена, а если нет, то все сделанные изменения в справочнике будут 
  отменены и выполнение процедуры будет прекращено.</p>
<h2><a name="_Toc503983477">Блокировка объектов базы данных</a></h2>
<p>В данном разделе рассматриваются различные стратегии и логика механизмов блокировок 
  базы данных системы 1С:Предприятие 7.7, используемых для обеспечения многопользовательского 
  режима работы. Как известно, все варианты системы 1С:Предприятие 7.7 способны 
  работать с базами данных в формате .DBF/.CDX. Кроме того, имеются варианты поставки 
  - 1С:Предприятие 7.7 для SQL, способные работать с базами данных, размещаемыми 
  в среде серверов баз данных Microsoft SQL Server 6.5/7.0. Естественно, что для 
  этих двух форматов баз данных используются совершенно разные механизмы доступа 
  к данным. Но при этом логика работы с базой данных в общем остается неизменной. 
  Соответственно, все, о чем будет рассказано в данном разделе является справедливым 
  для обоих возможных форматов построения баз данных системы 1С:Предприятие 7.7.</p>
<p>Блокировки, осуществляемые в базе данных системы 1С:Предприятие 7.7 можно разделить 
  на две группы:</p>
<ul>
  <li> Табличные (транзакционные) блокировки</li>
  <li> Блокировки отдельных объектов базы данных</li>
</ul>
<p>Табличные (транзакционные) блокировки , как следует из названия выполняются 
  на уровне таблиц и служат для обеспечения взаимодействия транзакций, выполняемых 
  несколькими экземплярами системы 1С:Предприятие в одной информационной базе. 
  Блокировки данного вида автоматически устанавливаются и снимаются программами 
  системы 1С:Предприятие в процессе отработки транзакций и предназначены для обеспечения 
  неизменности считанных данных в процессе выполнения транзакции. Имеются два 
  уровня табличных блокировок &quot;на чтение&quot; и &quot;на запись&quot;. Различаются 
  эти два уровня тем, что &quot;на чтение&quot; одна и та же таблица может быть 
  заблокирована более чем одним экземпляром системы 1С:Предприятие, в то время 
  как блокировка &quot;на запись&quot; является исключительной, то есть &quot;на 
  запись&quot; таблица может быть заблокирована только одним экземпляром системы.</p>
<p>Работают табличные блокировки следующим образом. Если в процессе выполнения 
  транзакции производится чтение из какой-либо таблицы базы данных, то предпринимается 
  попытка заблокировать данную таблицу &quot;на чтение&quot; (если она не была 
  заблокирована ранее &quot;на чтение&quot; или &quot;на запись&quot;). Если попытка 
  завершается успешно, то чтение завершается успешно и выполнение транзакции продолжается. 
  При этом блокировка с таблицы не снимается до завершения выполнения транзакции. 
  Другие же экземплярами системы 1С:Предприятие лишаются возможности выполнять 
  операции записи в эту таблицу, так как это нарушит принцип неизменности данных, 
  считанных в процессе выполнения транзакции.</p>
<p>Аналогично, если в процессе выполнения транзакции выполняется операция записи, 
  то предпринимается попытка заблокировать таблицу, в которую выполняется запись 
  (если, конечно, блокировка не была установлена ранее) . Если установка блокировки 
  завершается успешно, то операция записи также успешно завершается и таблица 
  остается заблокированной до завершения выполнения транзакции. При этом транзакции, 
  выполняемые другими экземплярами системы 1С:Предприятие лишаются возможности 
  производить чтение из заблокированной &quot;на запись&quot; таблицы, так как 
  для них не может быть гарантирована неизменность считанных ими данных.</p>
<p>Установка табличных блокировок выполняются с таймаутом. Это означает, что в 
  случае неудачной попытки установить блокировку таблицы сразу, попытки будут 
  повторяться в течение некоторого интервала времени. Этот интервал может устанавливаться 
  пользователем с помощью параметра &quot;Время ожидания захвата таблиц Базы Данных&quot;, 
  который доступен через диалог установки параметров системы 1С:Предприятие (пункт 
  меню &lt;Сервис/Параметры&gt;, страница диалога &lt;Общие&gt;).</p>
<p>Блокировки отдельных объектов базы данных предназначены для обеспечения корректного 
  взаимодействия между несколькими экземплярами системы 1С:Предприятие при изменении 
  таких объектов как константа, элемент справочника, документ, счет бухгалтерского 
  учета и т. п. Блокировки отдельных объектов бывают двух видов:</p>
<ul>
  <li>&quot;Пессимистические&quot;</li>
  <li>&quot;Оптимистические&quot;</li>
</ul>
<p>&quot;Пессимистические&quot; блокировки предназначены для обеспечения исключительного 
  доступа для изменения к объектам базы данных системы 1С:Предприятие. Данный 
  вид блокировок хорошо знаком пользователям системы 1С:Предприятие. В частности 
  &quot;пессимистическая&quot; блокировка автоматически устанавливается системой 
  1С:Предприятие при начале редактирования в форме или списке констант, элементов 
  справочников, документов и т. п. Установка &quot;пессимистической&quot; блокировки 
  не позволяет никому (кроме того, кто заблокировал объект) модифицировать заблокированный 
  объект. Только одна &quot;пессимистическая&quot; блокировка может быть установлена 
  для одного объекта базы данных. Это означает, что если тот или иной объект открыт 
  для редактирования одним экземпляром системы 1С:Предприятие, то не только другой 
  экземпляр системы 1С:Предприятия не сможет открыть для редактирования или изменить 
  этот объект, но и никакой модуль встроенного языка в рамках того же экземпляра 
  не сможет его модифицировать.</p>
<p>В более ранних чем 7.7 версиях системы 1С:Предприятие механизм &quot;пессимистических&quot; 
  блокировок использовался только при редактировании тех или иных объектов базы 
  данных и никак не мог быть задействован из встроенного языка. В версии 7.7 введена 
  возможность явной блокировки объектов из встроенного языка. Данная возможность 
  доступна только для объектов, создаваемых посредством обращения к функции СоздатьОбъект 
  . Соответственно, таким способом могут быть заблокированы такие объекты базы 
  данных как элементы справочника, счета бухгалтерского учета и документы. Блокировка 
  отдельных объектов осуществляется с помощью обращения к методу Блокировка(&lt;ВклВыкл&gt;). 
  Необязательный параметр &lt;ВклВыкл&gt; обозначает действие, которое надо выполнить: 
  1 -  заблокировать объект базы данных, 0 -  разблокировать. Метод возвращает 
  значение, показывающее результат выполнения операции: 1 -  операция выполнена</p>
<p>успешно, 0 -  операция не выполнена. Если параметр при обращении к методу не 
  задан, то возвращается текущий статус блокировки объекта базы данных: 1 - заблокирован, 
  0 -  &quot;свободен&quot;. Следует понимать, что имеется в виду статус блокировки, 
  установленной этим же объектом типа справочник, документ или счет, а не каким-либо 
  другим объектом или другим экземпляром системы 1С:Предприятие. Примером использования 
  метода Блокировка может послужить следующий фрагмент модуля:</p>
<p>Спр = СоздатьОбъект(&quot;Справочник.Товары&quot;);</p>
<p>Спр.ВыбратьЭлементы();</p>
<p>Пока Спр.ПолучитьЭлемент() = 1 Цикл</p>
<p>      Пока Спр. Спр.Блокировка(1) = 0 Цикл</p>
<p>            Если Вопрос(&quot;Элемент справочника заблокирован! Повторить попытку?&quot;,</p>
<p>                  &quot;Да+Нет&quot;) = &quot;Нет&quot; Тогда</p>
<p>                  Возврат;</p>
<p>            КонецЕсли;</p>
<p>      КонецЦикла;</p>
<p>      // Модифицируем реквизиты элемента справочника</p>
<p>      Спр.Записать();  // Записываем измененный элемент справочника</p>
<p>КонецЦикла;</p>
<p>Следует обратить внимание, что после записи модифицированного элемента справочника 
  не производится снятия блокировки в явном виде. В этом нет необходимости, так 
  как блокировка автоматически снимается при переходе к следующему элементу с 
  помощью метода ПолучитьЭлемент().</p>
<p>Механизм &quot;оптимистических&quot; блокировок предназначен для обеспечения 
  непротиворечивости модификации объектов базы данных. Работают &quot;оптимистические&quot; 
  блокировки полностью автоматически. Отличие &quot;оптимистических&quot; блокировок 
  от &quot;пессимистических&quot; можно пояснить на примере. Предположим имеется 
  задача модификации справочника Товары (например, пересчет цен). Для выполнения 
  этой задачи может использоваться одна из двух имеющихся специальных обработок. 
  Каждая из них последовательно обходит элементы справочника и модифицирует их. 
  Однако первая, подобно тому, как это было показано в приведенном выше примере 
  перед модификацией блокирует элемент справочника, а вторая такой блокировки 
  не производит.</p>
<p>Теперь представим себе, что модификация справочника Товары производится одновременно 
  двумя экземплярами системы 1С:Предприятие. При этом Экземпляр 1 пользуется первым 
  вариантом обработки, а Экземпляр 2 -  вторым. При их взаимодействии может наблюдаться 
  следующий результат, если оба экземпляра &quot;встретятся&quot; на модификации 
  одного и того же элемента справочника:</p>
<table width="1%" border="1">
  <tr> 
    <th width="0" nowrap>Действия Экземпляра 1</th>
    <th width="0" nowrap>Действия Экземпляра 2</th>
    <th nowrap>Результат</th>
  </tr>
  <tr> 
    <td width="0">ПолучитьЭлемент() </td>
    <td width="0">&nbsp;</td>
    <td width="3%">ОК </td>
  </tr>
  <tr> 
    <td width="0">&nbsp;</td>
    <td width="0">ПолучитьЭлемент() </td>
    <td width="3%">ОК </td>
  </tr>
  <tr> 
    <td width="0">Блокировка(1) </td>
    <td width="0">&nbsp;</td>
    <td width="3%">&nbsp;</td>
  </tr>
  <tr> 
    <td width="0" height="11">&nbsp;</td>
    <td width="0" height="11">Записать()    </td>
    <td width="3%" height="11">  Ошибка! </td>
  </tr>
  <tr> 
    <td width="0">Записать()    </td>
    <td width="0">&nbsp;</td>
    <td width="3%">ОК </td>
  </tr>
</table>
<p>Из приведенной таблицы видно, что Экземпляр 2 не смог произвести запись элемента 
  справочника, заблокированного Экземпляром 1. Сработал механизм &quot;пессимистической&quot; 
  блокировки. Аналогично, если бы оба экземпляра системы 1С:Предприятие пользовались 
  первым вариантом обработки, то Экземпляр 2 не смог бы заблокировать элемент 
  справочника.</p>
<p>А теперь представим, что оба экземпляра системы 1С:Предприятие пользуются вторым 
  вариантом обработки. Тогда &quot;встреча&quot; на одном и том же элементе справочника 
  может пройти следующим образом:</p>
<table width="1%" border="1">
  <tr> 
    <th width="0" nowrap>Действия Экземпляра 1</th>
    <th width="0" nowrap>Действия Экземпляра 2</th>
    <th nowrap>Результат</th>
  </tr>
  <tr> 
    <td width="0">&nbsp;</td>
    <td width="0">ПолучитьЭлемент() </td>
    <td width="3%">ОК </td>
  </tr>
  <tr> 
    <td width="0">ПолучитьЭлемент() </td>
    <td width="0">&nbsp;</td>
    <td width="3%">ОК </td>
  </tr>
  <tr> 
    <td width="0">Записать()    </td>
    <td width="0">&nbsp;</td>
    <td width="3%">  Ошибка! </td>
  </tr>
  <tr> 
    <td width="0">&nbsp;</td>
    <td width="0">Записать()    </td>
    <td width="3%">ОК </td>
  </tr>
</table>
<p>Ошибка, которая происходит при записи элемента справочника Экземпляром 2 и 
  является следствием работы механизма &quot;оптимистических&quot; блокировок. 
  Как было упомянуто выше, задачей механизма &quot;оптимистических&quot; блокировок 
  является обеспечение непротиворечивости модификации объектов базы данных. В 
  данном же случае имеет место следующее. Экземпляр 2 считал элемент справочника 
  и приступил к его модификации. В это время Экземпляр 1 успел считать, модифицировать 
  и записать этот же элемент справочника. Когда Экземпляр 2 приступил к выполнению 
  операции записи, значения реквизитов элемента справочника уже отличались от 
  тех, которые были считаны перед модификацией. И в данной ситуации запись элемента 
  справочника может привести к некорректным результатам, так как в общем случае, 
  модификация реквизитов может производиться исходя из их предшествующего состояния, 
  которое оказалось изменившимся.</p>
<p>Таким образом, можно сформулировать различия в логике функционирования двух 
  рассматриваемых механизмов блокировок. Логика механизма &quot;оптимистических&quot; 
  блокировок исходит из предположения (оптимистического), что в промежутке между 
  считыванием и записью измененного состояния объекта вероятность того, что этот 
  же объект будет изменен кем-то другим невелика. Логика же механизма &quot;пессимистических&quot; 
  блокировок в соответствии с их названием исходит из того, что случиться может 
  всякое и лучше, если объект будет гарантированно защищен от посторонних изменений.</p>
<h2><a name="_Toc503983478">Вычисление логических выражений в операторах встроенного языка</a></h2>
<p>В условных операторах и операторах цикла встроенного языка системы 1С:Предприятие 
  для определения последовательности выполняемых действий используются логические 
  выражения. Логическим выражением может быть элементарное логическое выражение 
  (сравнение двух значений) или более сложные конструкции полученные из элементарных 
  логических выражений при помощи логических операций И/ИЛИ/НЕ.</p>
<p>  Логические выражения могут быть весьма сложными и изощренными. И здесь у 
  разработчика конфигурации может возникнуть сложности, связанные с неправильным 
  пониманием правил вычисления логических выражений. Рассмотрим пример.</p>
<p>  Предположим, имеется процедура, предназначенная для обработки некоторого 
  реквизита справочника или документа. Тип данного реквизита не определен, а процедура 
  может вызываться для любого значения реквизита вне зависимости от его типа. 
  Процедура может иметь вид:</p>
<p>Процедура Обработать(Об)</p>
<p>    Если (ТипЗначенияСтр(Об) = &quot;Справочник&quot;) И (Об.Вид() = &quot;Товары&quot;) 
  Тогда</p>
<p>        // Некоторые действия</p>
<p>    КонецЕсли;</p>
<p>    ...</p>
<p>КонецПроцедуры</p>
<p>Если в качестве значения параметра, передаваемого в данную процедуру, будет 
  фигурировать элемент справочника любого вида, то процедура будет работать нормально, 
  но если в качестве параметра будет передано значение типа &quot;Число&quot; 
  или &quot;Дата&quot;, то выполнение процедуры будет аварийно завершено. В логическом 
  выражении, используемом в операторе 'Если' только составляющая ТипЗначенияСтр(Об) 
  = &quot;Справочник&quot; будет корректно функционировать независимо от типа 
  передаваемого параметра, а составляющая Об.Вид() = &quot;Товары&quot; сможет 
  нормально работать только в том случае, если в качестве параметра в процедуру 
  передано значение агрегатного типа и для данного агрегатного типа определен 
  метод Вид(). Дело в том, что при вычислении логических выражений встроенный 
  язык системы 1С:Предприятие 7.х сначала вычисляет элементарные логические выражения 
  (операции сравнения), а затем производит вычисление логического выражения в 
  целом (операции И/ИЛИ/НЕ).</p>
<p>  Таким образом, данная процедура не сможет корректно работать с параметром 
  заранее не определенного типа и может при выполнении вызвать ошибку, что неприемлемо. 
  Очевидно, что для правильного функционирования процедуры при ее разработке следовало 
  учесть порядок вычисления логических выражений, принятый во встроенном языке 
  системы 1С:Предприятие 7.х. То есть, чтобы работоспособность процедуры сохранялась 
  при любом значении параметра, процедура должна выглядеть как:</p>
<p>Процедура Обработать(Об)</p>
<p>    Если ТипЗначенияСтр(Об) = &quot;Справочник&quot; Тогда</p>
<p>        Если Об.Вид() = &quot;Товары&quot; Тогда</p>
<p>            // Некоторые действия</p>
<p>        КонецЕсли</p>
<p>    КонецЕсли</p>
<p>    ...</p>
<p>КонецПроцедуры</p>
<p>В данном случае порядок вычисления логических выражений в операторах Если выражен 
  в явном виде и выражение Об.Вид() = &quot;Товары&quot; будет вычисляться только 
  в том случае если условие ТипЗначенияСтр(Об) = &quot;Справочник&quot; окажется 
  истинным и ошибки при выполнении процедуры не произойдет при любом значении 
  параметра.</p>
<p>Заметим, что приведенный выше порядок вычислений не распространяется на вычисление 
  выражений определяющих результат оператора &quot;?&quot;. Само условие оператора 
  &quot;?&quot; вычисляется по общим правилам логических выражений описанным выше, 
  но из двух выражений определяющих результат оператора &quot;?&quot; выполняется 
  только одно (в зависимости от результата логического выражения). То есть, в 
  одном из выражений определяющих результат оператора &quot;?&quot;  (не вычисляемом) 
  ошибок времени выполнения не будет возникать вне зависимости от используемых 
  в нем конструкций.</p>
<h2><a name="_Toc503983480">Особенности применения предопределенных процедур встроенного языка</a></h2>
<p>Во встроенном языке системы 1С:Предприятие 7.x предусмотрен ряд системных предопределенных 
  процедур При..., таких как &quot;ПриЗаписи&quot;, &quot;ПриУдаленииДокумента&quot;, 
  &quot;ПриУдаленииЭлемента&quot;, &quot;ПриЗаписиКонстанты&quot;, &quot;ПриОтменеПроведенияДокумента&quot; 
  и т. п., определяемых в различных модулях конфигурации и вызываемых системой 
  при выполнении соответствующих действий. Назначение указанных процедур состоит 
  в том, чтобы специалист по конфигурированию мог предусмотреть необходимые проверки 
  при интерактивном выполнении соответствующих операций, и, в случае необходимости, 
  имел возможность запретить их выполнение.</p>
<p>При этом следует учитывать следующие особенности данных процедур:</p>
<p>1. Указанные предопределенные процедуры не связаны непосредственно с действиями, 
  при выполнении которых они вызываются, а сам вызов производится только при интерактивном 
  выполнении указанных действий. Например, процедура &quot;ПриУдаленииДокумента&quot; 
  будет вызвана в том случае, когда удаление документа будет инициировано &quot;нажатием 
  кнопки&quot; в форме журнала. В то же время вызов этой предопределенной процедуры 
  не будет производиться, если удаление документа производится из какого-либо 
  модуля встроенного языка (например, из некоторой обработки).</p>
<p>2. Вызовы указанных предопределенных процедур не объединены с выполняемым действием 
  единой транзакцией. Это означает, что в случае интерактивного удаления документа, 
  само удаление документа выполняется в транзакции, отдельной от действий, которые 
  могут выполняться в процедуре &quot;ПриУдаленииДокумента&quot;. И если в процедуре 
  &quot;ПриУдаленииДокумента&quot; действия будут выполняться в раках одной, явно 
  определенной в процедуре транзакции, то все равно приходится говорить о двух 
  транзакциях:</p>
<p>  - удаление документа;</p>
<p>  - действия, выполняемые в процедуре &quot;ПриУдаленииДокумента&quot;</p>
<p>Примером неправильного применения таких предопределенных процедур является 
  использование предопределенных процедур группы &quot;При...&quot; для выполнения 
  действий критичных с точки зрения поддержки целостности данных. Например, при 
  записи документа создается, записывается и проводится ряд связанных с ним документов 
  (процедура &quot;ПриЗаписи&quot; модуля формы документа). И эти же связанные 
  документы удаляются при удалении &quot;ведущего&quot; документа (процедура &quot;ПриУдаленииДокумента&quot; 
  глобального модуля).</p>
<p>Такую технику вряд ли следует признать правильной, в силу приведенных выше 
  особенностей предопределенных процедур. Так как предопределенные процедуры не 
  связаны жестко с выполняемыми действиями, то вполне вероятно, что при очередном 
  изменении конфигурации удаление документа станет выполняться не из формы журнала, 
  а из специально созданной обработки, что приведет к тому, что процедура &quot;ПриУдаленииДокумента&quot; 
  в данном случае вызываться не будет и, соответственно, не будут произведены 
  необходимые для этого случая действия. Но если возникновение ситуаций такого 
  рода еще можно как-топредотвратить путем более тщательной проработки конфигурации, 
  то объединить действия, выполняемые в рамках процедуры &quot;ПриУдаленииДокумента&quot; 
  и собственно удаление документа в одну транзакцию не возможно. При этом разнесение 
  единого по логике действия в разные транзакции может быть весьма опасно с точки 
  зрения поддержания логической целостности данных, так как ситуация, когда одно 
  действие выполняется, а другое по каким-либо причинам - нет, вполне вероятна, 
  особенно в многопользовательских системах.</p>
<p>Заметим, что описанные выше особенности предопределенных процедур не распространяются 
  на предопределенные процедуры &quot;ОбработкаПроведения&quot; и &quot;ОбработкаУдаленияПроведения&quot;. 
  Эти предопределенные процедуры вызываются непосредственно в транзакции проведения 
  (отмены проведения) и выполняемые в них алгоритмы логически связанны с самим 
  выполняемым действием. Кроме того, в отличие от других предопределенных процедур 
  эти предопределенные процедуры выполняются и в случае проведения (отмены проведения) 
  средствами встроенного языка.</p>
<h2><a name="_Toc503983482">Сохранение (восстановление) значений в строку</a></h2>
<p>         В 1С:Предприятии существует несколько способов, позволяющих преобразовать 
  значение к строковому виду и восстановить его обратно из строки.</p>
<p>         Заметим, что в данном случае речь идет не о преобразовании к строке 
  значения вызовом функции &quot;Строка&quot; или аналогичном автоматическом преобразовании 
  в выражении строкового типа. Такое преобразование используется лишь для получения 
  визуального представления значения и кроме типов &quot;число&quot;, &quot;строка&quot;, 
  &quot;дата&quot;, не имеет возможности обратного преобразования.</p>
<p>          В данном разделе описываются способы, которые ориентированы на преобразование 
  значения в строку с целью его обратного преобразования к исходному типу. Эти 
  возможности используются обычно для решения специальных задач, связанных с хранением 
  значений вне информационной базы или передачи данных в другую информационную 
  базу или программу.</p>
<p>          Следует учитывать, что применение таких преобразований требует хорошего 
  понимания данного механизма и системы 1С:Предприятия в целом.</p>
<p>Какие значения преобразуются в строку.</p>
<p>         К строковому виду могут быть преобразованы значения любых типов, которые 
  могут храниться в информационной базе, то есть тех типов, которые доступны, 
  например, при создании реквизита документа. Это, прежде всего, базовые типы 
  (&quot;число&quot;, &quot;строка&quot;, &quot;дата&quot;), а также типы определяемые 
  метаданными (&quot;перечисление&quot;, &quot;счет&quot;, &quot;справочник&quot;, 
  &quot;документ&quot; и т.д.).</p>
<p>Кроме того, к строке могут быть преобразованы значения типа &quot;СписокЗначений&quot; 
  и &quot;ТаблицаЗначений&quot;, которые фактически представляют собой набор отдельных 
  значений.</p>
<p>         Значения других типов используемых во встроенном языке 1С:Предприятия, 
  но не хранящиеся в информационной базе (например, &quot;Таблица&quot; или &quot;Запрос&quot;) 
  не могут быть преобразованы к строке.</p>
<p>         При сохранении в строку значений типа &quot;СписокЗначений&quot; и 
  &quot;ТаблицаЗначений&quot; допускается вложенное преобразование значений. То 
  есть при преобразовании списка значений  будет преобразовываться в строку все 
  значения входящие в список, включая списки значений и таблицы значений. Разумеется, 
  не будут преобразовываться в строку входящие в список значения, которые сами 
  не могут быть преобразованы к строке.</p>
<p>         Также следует иметь в виду, что преобразуются к строке отдельные значения, 
  а не объекты данных. То есть, можно преобразовать к строке значение реквизита 
  элемента справочника, но нельзя преобразовать к строке весь элемент справочника 
  целиком. Для сохранения в строке элемента справочника, необходимо сохранять 
  отдельно все его реквизиты.</p>
<p>Способы преобразования к строке.</p>
<p>      Значения могут преобразовываться к строке в двух разных форматах - внутреннем 
  и внешнем. Использование этих форматов существенно отличается по своему назначению 
  и возможностям. При преобразовании к строке формат (внутренний или внешний) 
  всегда задается явно. Он определяется именем функции или ее параметром. При 
  обратном преобразовании (из строки) необходимо вызывать соответствующую функцию 
  преобразования именно из того формата, в котором выполнялось сохранение значения 
  в сроковом виде.</p>
<p>Внутренний формат.</p>
<p>Для преобразования к строковому виду (и обратно) во внутреннем формате используются 
  следующие функции:</p>
<p>- ЗначениеВСтрокуВнутр / ЗначениеИзСтрокиВнутр;</p>
<p>- ЗначениеВФайл / ЗначениеИзФайла - параметр &quot;Формат&quot; =1;</p>
<p>- СохранитьЗначение / ВосстановитьЗначение.</p>
<p>Кроме того, во внутреннем строковом формате хранятся значения расшифровок табличного 
  документа.</p>
<p>      Значение, полученное в сроковом виде во внутреннем формате, может быть 
  преобразовано из строки к исходному типу только в той же информационной базе. 
  Это объясняется тем, что для сохранения значения во внутреннем формате используются 
  системные идентификаторы (не отображаемые на экране), как объектов метаданных, 
  так и объектов данных. При попытке преобразовать значение, сохраненное во внутреннем 
  формате, в другой конфигурации может произойти неправильное преобразование значения.</p>
<p>      Если объект данных в информационной базе, на который ссылалось значение, 
  удален (например, элемент справочника), то при преобразовании значения из строки 
  обращение к этому значению не вызовет системной ошибки, но, разумеется и не 
  позволит получить данные удаленного объекта.</p>
<p>      Строки, полученные преобразованием значений к строке во внутреннем формате 
  нельзя хранить в информационной базе. Прежде всего, это приведет к нарушению 
  работы механизма контроля ссылочной целостности. Также, это может повлиять на 
  работу компоненты &quot;Управление распределенными данными ИБ&quot;.  Разумеется, 
  такое хранение значений, также не позволит системе оптимизировать обращение 
  к данным при использовании версий 1С:Предприятия для SQL. Заметим, что хранение 
  в информационной базе значений преобразованных в строку нарушает идеологию 1С:Предприятия 
  и затрудняет отладку и модификацию конфигураций.</p>
<p>      Отдельно следует отметить возможность использования преобразования значений 
  к строке во внутреннем формате для однозначной идентификации объектов, при переносе 
  информации из одной информационной базы в другую. То есть, при загрузке некоторых 
  данных из другой информационной базы строковые представления значений другой 
  ИБ в данной ИБ не могут использоваться собственно для обратного преобразования, 
  но могут использоваться для сопоставления двух значений той ИБ, из которой идет 
  загрузка. Например, если загружается справочник, то ссылку на родителя загружаемого 
  элемента можно сопоставить со ссылкой ранее загруженной группы справочника, 
  для точной идентификации родителя. Разумеется, сопоставлять можно только строки, 
  полученные в одной информационной базе. То есть в описанном примере строковое 
  представление во внутреннем формате должно выгружаться и для самих групп и для 
  родителей элементов, чтобы при загрузке их можно было сопоставить. Для сопоставления 
  можно рекомендовать запоминать при загрузке групп строковые представления этих 
  групп в исходной ИБ, а при загрузке элементов искать группу соответствующую 
  загружаемому элементу по строковому представлению родителя элемента в исходной 
  ИБ.</p>
<p>Внешний формат</p>
<p>Для преобразования к строковому виду во внешнем формате используются</p>
<p>следующие функции:</p>
<p>- ЗначениеВСтроку / ЗначениеИзСтроки;</p>
<p>- ЗначениеВФайл / ЗначениеИзФайла - параметр &quot;Формат&quot; =0.</p>
<p>В отличие от внутреннего формата, при преобразовании значения в строку во внешнем 
  формате система использует не системные идентификаторы объектов метаданных и 
  данных, а обычные строковые идентификаторы объектов метаданных и те значения 
  данных, на основании которых можно однозначно идентифицировать объект. Например, 
  для преобразования к строке во внешнем формате значения типа &quot;Справочник.Товары&quot; 
  будет использован идентификатор справочника &quot;Товары&quot;, а также код 
  элемента справочника. Если для кода справочника уникальность установлена в пределах 
  группы, то будет использован полный код с учетом всех вышестоящих групп. Если 
  справочник является подчиненным, то для идентификации значения будут использован 
  код элемента справочника -  владельца. Разумеется, если для справочника отключен 
  контроль уникальности кодов, то преобразование значения этого типа практически 
  не имеет смысла. Для сохранения значения типа &quot;документ&quot;, если уникальность 
  номеров поддерживается в пределах некоторого интервала (года, месяца), то для 
  сохранения и восстановления значения используется также дата документа.</p>
<p>      Внешний формат преобразования к строке может использоваться для переноса 
  значений между различными информационными базами. Разумеется, успех обратного 
  преобразования зависит от того, имеются ли в той информационной базе, в которой 
  значение преобразуется из строки объекты метаданных с соответствующими идентификаторами 
  и объекты данных соответствующими кодами/номерами. Например, полученное нами 
  в строковом виде значение  типа &quot;Справочник.Товары&quot;, будет правильно 
  обратно  преобразовано, если имеется справочник, товары и элемент справочника 
  с тем кодом, который был у элемента, на который ссылалось значение преобразованное 
  к строке.</p>
<p>      При восстановлении значения из строки во внешнем формате преобразование 
  может быть не выполнено по нескольким причинам. Например, в той конфигурации, 
  в которой происходит преобразование из сроки, не существует объекта метаданных 
  с идентификатором, соответствующим типу значения, сохраненного в строке. Другой 
  причиной может быть отсутствие в информационной базе объекта данных с тем кодом 
  (номером), который был у элемента справочника, документа или счета, на который 
  ссылалось сохраненное в строке значение. Кроме того, преобразование может быть 
  не выполнено из-за отличий в свойствах объектов метаданных. Например, если при 
  сохранении в строку значения типа &quot;Справочник.Товры&quot; у справочника 
  &quot;Товары&quot; была установлена уникальность кода в пределах подчинения, 
  а при восстановления значения из строки уникальность кода была установлена в 
  пределах всего справочника, то значение из строки не будет восстановлено. Однако, 
  неудачное  преобразование из строки не вызывает системной ошибки, а приводит 
  лишь к получению пустого значения.</p>
<p>      Заметим, что возможность преобразования к строке во внешнем формате может 
  использоваться при передаче данных из одной информационной базы 1С:Предприятия 
  в другую с помощью Ole Automation, так как непосредственно передать значение 
  типа &quot;справочник&quot;, &quot;документ&quot; и т.п. через Ole</p>
<p>Automation нельзя.</p>
<p>      Следует учитывать, что восстановление значений типа &quot;справочник&quot;, 
  &quot;документ&quot; или &quot;счет&quot; из строки во внешнем формате в отличие 
  от использования внутреннего формата занимает определенное время, так как при 
  этом выполняется обращение к информационной базе для поиска значений по сохраненному 
  номеру (коду).</p>
<p>      Заметим, что преобразование к строке и обратно значений типа &quot;число&quot;, 
  &quot;строка&quot; и &quot;дата&quot; происходит однозначно (гарантированно) 
  в обоих форматах, так как эти значения не зависят от конфигурации. В качестве 
  примера такого сохранения в методической конфигурации в обработке &quot;НастройкаПрописи&quot; 
  выполняется сохранение в файле строк, используемых для вывода чисел, дат и периодов 
  прописью.</p>
<h2><a name="_Toc503983483">Работа со значениями агрегатных типов во встроенном 
  языке</a></h2>
<p>При работе со значениями агрегатных типов во встроенном языке системы 1С:Предприятие 
  следует учитывать некоторые особенности, которые не всегда являются очевидными.</p>
<p>Каждое значение агрегатного типа в системе 1С:Предприятие включает две составляющие:</p>
<ul>
  <li> внутренний идентификатор объекта данных;</li>
  <li> ссылка на объект доступа.</li>
</ul>
<p>  Внутренний идентификатор объекта предназначен для максимально полной идентификации 
  объекта, соответствующего значению агрегатного типа. А объект доступа служит 
  для обращения к объекту данных посредством реквизитов и методов. При выполнении 
  присваивания переменной встроенного языка значения агрегатного типа, в переменную 
  копируется внутренний идентификатор объекта и ссылка на объект доступа, если 
  таковой имеется. Сам объект доступа при этом не копируется! Таким образом, в 
  результате</p>
<p>выполнения оператора</p>
<p>A = B;</p>
<p>при условии, что переменная B имела значение агрегатного типа и уже имела ссылку 
  на объект доступа, переменные A и B будут ссылаться на один и тот же объект 
  доступа.  В отличие от базовых типов (число, строка, дата), для которых при 
  присваивании копируется само значение, при присваивании агрегатных типов копируется 
  не объект доступа, а только ссылка на него.</p>
<p>  Здесь, однако, следует учитывать, что не всегда значение агрегатного типа 
  содержит ссылку на тот или иной объект доступа. В некоторых случаях объекта 
  доступа, соответствующего значению агрегатного типа может еще не существовать.</p>
<p>  Значение агрегатного типа всегда содержит ссылку на объект доступа в тех 
  случаях, когда значение было создано с помощью функции СоздатьОбъект().   А 
  вот у атрибутов запросов,  реквизитов справочников, документов и т. п., имеющих 
  агрегатный тип, значения изначально не содержат ссылок на объекты доступа, пока 
  они не будут созданы при обращении к атрибутам и методам. Соответственно и при 
  присваивании таких значений переменным встроенного языка, переменные также не 
  приобретают ссылок на объекты доступа, если они еще не были созданы.</p>
<p>  Как же тогда в таких случаях происходит обращение к атрибутам и методам? 
  Дело в том, что значение агрегатного типа, у которого нет ссылки на объект доступа 
  может существовать только для конкретных типов системы 1С:Предприятие - элементов 
  справочников, документов, счетов бухгалтерского учета и т. п.. И здесь выручает 
  внутренний идентификатор объекта, который всегда содержится в значении агрегатного 
  типа и для указанных типов может предоставить исчерпывающую информацию, необходимую 
  для создания объекта. А само создание объекта доступа производится при первом 
  обращении его методу или атрибуту. Поясним вышесказанное на примере:</p>
<p>Тов = Док.Товар;   // Объект доступа еще не создан, при условии, что ранее 
  не было обращений к атрибутам и методам;</p>
<p>Тов2 = Док.Товар;  // Аналогично</p>
<p>Цена = Тов.Цена;   // Для переменной Тов создается объект доступа</p>
<p>Цена2 = Тов2.Цена; // Для переменной Тов2 создается объект доступа. Тов и Тов2 
  ссылаются на разные объекты доступа</p>
<p>Тов3 = Тов;        // Тов и Тов3 ссылаются на один объект доступа</p>
<p>  При создании объекта доступа происходит считывание данных объекта информационной 
  базы. В дальнейшем значения прочитанных реквизитов остаются неизменными, вне 
  зависимости от изменений, производимых в информационной базе. Поэтому не следует, 
  сохранять в переменных на продолжительный период значения, соответствующие элементам 
  справочников, документам и т. п., в надежде, что в их реквизитах будут отображаться 
  актуальные на текущий момент значения.</p>
<p>  Надо отметить, что объекты доступа продолжают существовать до тех пор, пока 
  на них есть ссылки. Для приведенного выше примера уничтожение объектов, созданных 
  для доступа к реквизитам элемента справочника может быть вызвано выполнением 
  последовательности операторов:</p>
<p>Тов = 0;   // Удалена ссылка на объект доступа</p>
<p>Тов2 = 0;  // Уничтожен первый объект доступа</p>
<p>Тов3 = 0;  // Уничтожен второй объект доступа</p>
<p>В результате выполнения этих операторов ссылки на объекты доступа удаляются 
  путем присваивания переменным других значений. Ссылки на объекты доступа были 
  бы также уничтожены при выходе из процедуры или функции, для которой переменные 
  Тов, Тов2 и Тов3 были локальными. Если же переменная, содержащая ссылку на объект 
  доступа, является глобальной переменной глобального модуля, то единственный 
  способ уничтожить ссылку на объект доступа - это присвоить переменной другое 
  значение.</p>
<p>  Теперь рассмотрим случай, когда обращение к реквизиту происходит не через 
  одну, как в рассмотренных выше примерах, а через две и более точек? Например, 
  в случае выполнения оператора:</p>
<p>Цена = Док.Товар.Цена;</p>
<p>В этом случае, исполняющая система встроенного языка получает значение реквизита 
  Товар документа, представленного значением переменной Док. При этом полученное 
  значение не будет содержать ссылки на объект доступа. Затем, исполняющая система 
  создает объект доступа, соответствующий реквизиту Товар, и, затем, с помощью 
  созданного объекта, получает значение реквизита Цена. Затем объект доступа удаляется, 
  так как ни одна из переменных после выполнения указанного оператора на объект 
  не ссылается. Таким образом, при выполнении последовательности операторов</p>
<p>Наимен = Док.Товар.Наименование;</p>
<p>Цена = Док.Товар.Цена;</p>
<p>объект доступа, соответствующий Док.Товар будет дважды создан и дважды уничтожен. 
  С точки зрения производительности для достижения той же цели было бы эффективнее 
  воспользоваться последовательностью операторов:</p>
<p>Тов = Док.Товар;  // Присваивается реквизит документа. Объект доступа еще не 
  создан</p>
<p>Наимен = Тов.Наименование; //  Для переменной Тов создается объект доступа</p>
<p>Цена = Тов.Цена;  // Используется созданный ранее объект доступа</p>
<p>При выполнении данной последовательности объект для доступа к элементу справочника 
  создается однократно и, после выполнения указанных операторов, переменная Тов 
  сохранит ссылку на объект доступа и он сможет быть использован в дальнейшем, 
  до тех пор, пока переменной не будет присвоено другое значение или произойдет 
  возврат из процедуры или функции, в которой переменная определена.</p>
<h2><a name="_Toc503983484">Значения типов, соответствующих объектам информационной 
  базы во встроенном языке</a></h2>
<p>Для таких объектов информационной базы системы 1С:Предприятие как справочники, 
  документы и счета бухгалтерского учета значения, представляющие  эти объекты 
  во встроенном языке могут выступать в двух разных видах:</p>
<p>  - значения, полученные путем вызова системной функции СоздатьОбъект</p>
<p>  - значения полученные из реквизитов форм и атрибутов объектов информационной 
  базы</p>
<p>  Значения, полученные при помощи вызова СоздатьОбъект() не представляют какой-то 
  конкретный объект (элемент справочника, документ, счет бухгалтерского учета), 
  а предназначены главным образом  для обработки групп объектов. С помощью таких 
  значений можно получать выборки множества объектов, последовательно обходить 
  объекты, попавшие в выборку, производить их обновление, создавать новые и удалять 
  существующие объекты  и т. п.. Такие значения могут использоваться &quot;многократно&quot;, 
  то есть с помощью одного значения можно получить доступ сначала к одной выборке, 
  потом к другой и так много раз.</p>
<p>  Значения, содержащихся в реквизитах форм и атрибутах объектов информационной 
  базы, являются точными значениями и представляют ровно один конкретный объект 
  информационной базы (элемент справочника, документ, счет бухгалтерского учета). 
  Такие значения также могут быть пустыми – не представляющими никакого объекта. 
  С помощью таких значений можно получать доступ к атрибутам соответствующего 
  объекта, но нельзя производить действий по созданию, удалению и изменению объекта.</p>
<p>  Но несмотря на такие существенные различия оба описанных варианта значений 
  одинаковы во многих проявлениях. Рассмотрим пример:</p>
<p>Спр1 = СоздатьОбъект(&quot;Справочник.Товары&quot;);</p>
<p>Спр2 = Док.Товар;</p>
<p>Переменные Спр1 и Спр2 содержат значения двух описанных выше видов. Для этих 
  переменных способ доступа к атрибутам справочника производится одним и тем же 
  способом. Многие методы объекта типа Справочник могут применяться как к Спр1, 
  так и Спр2. Функции ТипЗначения() и ТипЗначенияСтр(), будучи  примененными к 
  Спр1 и Спр2 дадут одинаковые результаты. Многие методы встроенного языка также 
  не различают какого вида значение передано им в качестве параметра: точное значение 
  объекта или спозиционированная выборка.</p>
<p>И такое положение дел приводит к тому, что иногда у специалистов по конфигурированию 
  возникают трудности с пониманием различия между приведенными видами значений. 
  В результате при написании конфигураций возникают ситуации, когда одной и той 
  же процедуре в качестве параметра могут передаваться значения разных видов:</p>
<p>1.</p>
<p>Спр1 = СоздатьОбъект(&quot;Справочник.Товары&quot;);</p>
<p>Спр1.ВыбратьЭлементы();</p>
<p>Пока Спр1.ПолучитьЭлемент() = 1 Цикл</p>
<p>    Обработать(Спр1);</p>
<p>КонецЦикла;</p>
<p>2.</p>
<p>Спр2 = Док.Товар;</p>
<p>Обработать(Спр2);</p>
<p>В первом случае в качестве параметра процедуре Обработать() передается выборка, 
  спозиционированная на конкретный элемент справочника, а во втором - точное значение 
  элемента справочника. И, если, например, в процедуре Обработать() производится 
  только считывание реквизитов справочника, то результаты, полученные в обоих 
  случаях будут неразличимы. Но если в процедуре Обработать() производится присвоение 
  переданного в качестве параметра значения реквизиту формы или атрибуту объекта 
  (например, документа), то первый вариант просто не будет работать, так как вместо 
  точного значения элемента справочника процедура получит выборку. Для того, чтобы 
  все работало нормально первый вариант должен выглядеть так:</p>
<p>Спр1 = СоздатьОбъект(&quot;Справочник.Товары&quot;);</p>
<p>Спр1.ВыбратьЭлементы();</p>
<p>Пока Спр1.ПолучитьЭлемент() = 1 Цикл</p>
<p>    Обработать(Спр1.ТекущийЭлемент());</p>
<p>КонецЦикла;</p>
<p>Функция ТекущийЭлемент() в качестве значения возвращает точное значение элемента 
  справочника, на который спозиционирована выборка. А если функция ТекущийЭлемент() 
  применяется к переменной, значением которой является уже точное значение элемента 
  справочника, эта функция вернет само это значение. Так что равноценным вариантом 
  решения показанной в примере проблемы было бы, если  для выполнения действий 
  процедура Обработать() использовала бы не сам переданный параметр, а значение 
  некоторой переменной (например, Спр), значение которое получила бы из переданного 
  параметра (Парам) следующим способом:</p>
<p>Спр = Парам.ТекущийЭлемент();</p>
<p>Однако следует иметь в виду, что при вызове метода  ТекущийЭлемент() у переменной, 
  значение которой получено из реквизитов форм и атрибутов объектов информационной 
  базы, а не путем вызова функции СоздатьОбъект() будет выполняться поиск элемента 
  справочника в информационной базе, что повлечет к дополнительным затратам времени.  
  Соответственно, если полученное конкретное значение предполагается просто присвоить 
  (например, измерению регистра), а не обращаться к его атрибутам и методам, и 
  известно, что это именно конкретное значение, а не выборка, использовать метод 
  ТекущийЭлемент() не следует. Поэтому можно рекомендовать создавать процедуры 
  ориентированные на получение в качестве параметра только конкретного значения, 
  а при вызове процедуры с передачей в качестве фактического параметра выборки  
  вызывать метод ТекущийЭлемент().</p>
<p>Обработать(Спр1.ТекущийЭлемент());</p>
<p>Аналогичные соображения справедливы для объектов типа документ и счет бухгалтерского 
  учета. Для документов аналогом функции ТекущийЭлемент() является функция ТекущийДокумент(), 
  а для счетов  бухгалтерского учета - ТекущийСчет().</p>
<h2><a name="_Toc503983486">Выбор разрядности для данных числовых типов</a></h2>
<p>Выбор разрядности для данных числовых типов При описании формата числового 
  типа данных первая цифра означает полное число знакомест в представлении числа 
  (с учетом позиции, занимаемой десятичной точкой, но без учета позиции под знак 
  числа), вторая цифра означает число знакомест в дробной части числа. Поэтому, 
  если мы задали формат числа (8.2), то это означает, что число будет представляться 
  с пятью знаками до десятичной точки и двумя знаками после (плюс один символ 
  на десятичную точку). </p>
<p>При установке формата числового типа данных, разрядность должна обеспечивать 
  возможность хранения чисел необходимой величины. Например, если у нас реквизит 
  "Цена" имеет формат (8.2), то при записи в него значения 10000 * 26.85 мы получим 
  переполнение числа (99999.99). </p>
<p>Аналогичные соображения следует учитывать при выборе формата таких данных как 
  ресурсы регистров оперативного учета, реквизиты многострочных частей документов, 
  для которых установлен флаг "Итог по колонке", суммы проводок и операций, и 
  т. п.. Для указанных величин необходимо помнить, что поля, в которых хранятся 
  значения перечисленных величин и поля, в которых размещаются итоговые значения 
  (суммы) имеют одинаковый формат. Поэтому, для такого рода числовых величин в 
  формате должно быть учтено не только максимальное значение отдельной величины, 
  но и максимально возможные значения сумм. Так, например, при выборе разрядности 
  ресурсов регистров оперативного учета следует устанавливать разрядность, которая 
  сможет вместить максимально возможный оборот и остаток по данному ресурсу. </p>
<h2><a name="_Toc503983487">Перебор объектов и групповое изменение данных</a></h2>
<p>Весьма часто при разработке и внедрении конфигураций возникает необходимость 
  в разработке алгоритма, который выполняет обход объектов информационной базы 
  и вносит в них некоторые изменения. При реализации такого алгоритма в определенных 
  случаях возникают ситуации, когда после изменения объекта не выполняется продолжение 
  выборки следующих объектов. Это объясняется тем, что последовательная выборка 
  и изменение объектов выполняются непосредственно в информационной базе. В основном 
  проблемы возникают в тех случаях, когда при записи изменяются именно те данные, 
  по которым собственно и происходит отбор объектов. В результате текущий объект 
  не должен больше относиться к выборке и само продолжение выборки не выполняется 
  системой. Например, в процессе перебора подчиненных документов, у найденного 
  документа изменяется реквизит, в котором собственно записано  значение того 
  документа, для которого выбираются подчиненные. Ситуация осложняется тем, что 
  при использовании методов языка разработчик конфигурации не всегда может точно 
  определить каким способом система будет выполнять перебор объектов.</p>
<p>Прежде всего, можно рекомендовать не выполнять изменение данных тем же объектом 
  (переменной) которой выполняется выбора, а создать для этой цели отдельную переменную 
  и позиционировать ее на выбранный объект информационной базы.</p>
<p>Чтобы однозначно избежать трудностей при разработке подобных алгоритмов имеет 
  смысл сначала выполнить обход объектов по некоторому критерию и занести их в 
  список значений, а затем позиционироваться на каждый объект, содержащийся в 
  списке и выполнять необходимые изменения.</p>
<p>Следует заметить, что при выполнении выборки объектов информационной базы с 
  помощью  объекта &quot;Запрос&quot; подобных проблем не возникает, так как при 
  обходе результатов запроса используется временный массив построенный в ходе 
  выполнения запроса.</p>
<h2><a name="_Toc503983488">Ошибки базы данных и их обработка</a></h2>
<p>Ошибки базы данных и их обработка. При работе системы 1С:Предприятие могут 
  возникать ошибки базы данных. Эти ошибки могут иметь место как при работе с 
  базой данных, представленной в формате DBF/CDX , так и с базой данных, хранимой 
  в среде MS SQL Server . И, хотя характер ошибок в обоих приведенных случаях 
  может различаться, процедура их обработки стандартизована в системе 1С:Предприятие. 
  По последствиям ошибки базы данных разделяются на две группы </p>
<ul>
  <li>невосстановимые ошибки </li>
  <li>восстановимые ошибки </li>
</ul>
<h4><b>Невосстановимые ошибки базы данных </b></h4>
<p>Невосстановимые ошибки базы данных являются следствием значительных нарушений 
  в работе системы 1С:Предприятие: физического разрушения базы данных, нарушения 
  ее структуры, серьезных рассогласований во взаимодействии программы с базой 
  данных и т. п.. В таких случаях восстановить нормальное функционирование системы 
  1С:Предприятие невозможно и единственно правильной реакцией является завершение 
  работы системы. Видимым проявлением таких ошибок в случае работы с базой данных 
  в формате DBF/CDX является появление диалогового окна, содержащего текст, начинающийся 
  со слов "Н евосстановимая ошибка Базы Данных”, в след за которыми приводится 
  описание ошибки. В случае работы с базой данных, размещенной в среде MS SQL 
  Server сначала появляется окно, в котором содержится описание ошибки SQL , а 
  затем окно, содержащее текст "Н евосстановимая ошибка базы данных!". П осле 
  этого в обоих случаях происходит завершение работы системы. Невосстановимые 
  ошибки базы данных не могут быть перехвачены и обработаны из встроенного языка 
  с помощью конструкций <b>Попытка … Исключение … КонецПопытки</b> . </p>
<h4>Восстановимые ошибки базы данных </h4>
<p>Восстановимые ошибки базы данных в известном смысле ошибками не являются, а 
  представляют собой штатные ситуации, которые так или иначе могут возникать в 
  процессе нормальной работы системы 1С:Предприятие. К восстановимым ошибкам относятся 
  ошибки блокировки отдельных объектов (записей) базы данных, ошибки захвата таблиц 
  при выполнении транзакций и т. п.. Ошибками они являются в том смысле, что при 
  этом не могут быть успешно завершены выполняемые над базой данных операции (транзакции). 
  Но при этом не происходит каких-то фатальных нарушений в работе системы 1С:Предприятие 
  и имеется возможность восстановления нормального функционирования. Реакция системы 
  на восстановимые ошибки базы данных зависит от того, в какой ситуации происходит 
  ошибка: при выполнении интерактивного действия или при выполнении модуля встроенного 
  языка.</p>
<p> При выполнении интерактивной процедуры (например, при записи документа из 
  формы при нажатии кнопки), в случае возникновения восстановимой ошибки базы 
  данных происходит откат транзакции базы данных, а сама система 1С:Предприятие 
  возвращается к состоянию, в котором она находилась до начала выполнения интерактивной 
  процедуры. После этого на экран выводится диалоговое окно, содержащее вопрос: 
  "П ри выполнении транзакции произошла ошибка! <О писание ошибки> П овторить 
  попытку выполнить транзакцию?". В случае положительного ответа на вопрос производится 
  повторная попытка выполнить операцию. Если повторная попытка выполнить операцию 
  снова завершится восстановимой ошибкой, то снова будет выдан запрос на повторение 
  операции и так далее. В случае отрицательного ответа повторная попытка выполняться 
  не будет. В модулях встроенного языка восстановимые ошибки базы данных могут 
  быть перехвачены и обработаны с помощью конструкции встроенного языкаПопытка 
  … Исключение … КонецПопытки так же, как и другие ошибки встроенного языка. В 
  случае, если обработки ошибки в модуле не предусмотрено, то будет произведен 
  откат выполняемой в данный момент транзакции, в окно сообщений 1С:Предприятия 
  будет выведено сообщение о произошедшей ошибке, а выполнение модуля будет прервано, 
  как и в случае возникновения в процессе выполнения модуля любой другой ошибки. 
  В случае работы с базой данных, размещенной в среде MS SQL Server , в окно сообщений 
  будет выдана ошибка SQL. После возникновения восстановимой ошибки алгоритм, 
  вызвавший ошибку, может быть вызван пользователем повторно. Если используется 
  конструкция встроенного языка <b>Попытка … Исключение … КонецПопытки</b>, то 
  повторная операции записи может быть вызвана модулем автоматически. </p>
<h2><a name="_Toc503983489">Использование строковых реквизитов неограниченной 
  длины</a></h2>
<p>При определении структуры справочников и документов для строковых реквизитов 
  необходимо выбрать определенную длину или указать режим &quot;Неограниченная 
  длина&quot; (кроме реквизитов табличной части). Вариант &quot;Неограниченная 
  длина&quot; существенно отличается по внутреннему способу хранения.</p>
<p>При работе с базами данных в формате DBF/CDX  реквизиты неограниченные длины 
  хранятся в отдельной таблице блоками по 80 символов. Для пустой строки в этой 
  таблице записи не хранятся. Разумеется, хотя само значение блока имеет длину 
  80 символов, дополнительные ресурсы расходуются на поддержание связи с этой 
  таблицей. В базах данных в формате SQL  для хранения реквизитов неограниченной 
  длины используется соответствующий тип поля таблицы, который также хранит только 
  заполненные строки. Соответственно, если в создаваемом реквизите значения будут 
  задаваться далеко не для всех объектов, то использование реквизита неограниченной 
  длины может существенно уменьшить количество используемого дискового пространства.</p>
<p>Обращение к реквизитам неограниченной длины несколько замедляет считывание 
  объекта, если происходит обращение к этим реквизитам. Запись объекта замедляется 
  несколько более существенно, но только если конкретное значение изменялось. 
  Скорость записи, разумеется, зависит от количества записываемых блоков (в базах 
  данных DBF/CDX), то есть от длины строки.</p>
<p>Следует учитывать, что строковые значения реквизитов неограниченной длины записываются 
  и возвращаются без хвостовых пробелов, тогда как обычные строковые реквизиты 
  всегда дополняются пробелами до длины соответствующей длине реквизита в метаданных.</p>
<h2><a name="_Toc503983490">Особенности работы с типизированными и не типизированными 
  колонками таблицы значений.</a></h2>
<p>При создании колонки таблицы значений можно указать или не указать тип значений, 
  которые будут храниться в данной колонке. Информация в типизированных и не типизированных 
  колонках таблицы значений хранится по-разному. В колонке с неуказанным типом 
  значения хранится значение и его контекст, тогда как в колонке с указанным типом 
  хранится только его значение. У каждого способа есть свои плюсы и минусы. Хранение 
  значения и контекста позволяет увеличить производительность при частых обращениях 
  к значениям реквизитов объектов, которые хранятся в таблице значений. Но при 
  этом расходуется много памяти на хранение каждого объекта. Хранение только значения 
  позволяет более компактно хранить информацию. Минусом является то, что при каждом 
  обращении к атрибуту или методу объекта, который хранится в такой колонке, объект 
  будет создаваться, позиционироваться на соответствующую запись и уничтожаться 
  после использования. Чтобы избежать таких накладных расходов, перед обращением 
  к нескольким атрибутам или методам объекта, рекомендуется поместить его значение 
  во временную переменную и использовать ее для доступа к атрибутам и методам 
  объекта. Данный способ позволяет компактно хранить информацию и получить хорошую 
  производительность при работе с большим объемом информации.</p>
<h2><a name="_Toc503983491">Применение процедуры ПриНачалеРаботыСистемы() глобального модуля</a></h2>
<p>В глобальном модуле может быть определена процедура ПриНачалеРаботыСистемы(), 
  которая вызывается на выполнение при запуске системы 1С:Предприятие. Данная 
  процедура предназначена для того, чтобы в конфигурации можно было определить  
  действия, которые должны быть выполнены при начале работы системы 1С:Предприятие. 
  Однако операторы тела глобального модуля (операторы, размещаемые в конце модуля 
  и не входящие в какую-нибудь процедуру) также выполняются при запуске системы 
  1С:Предприятие. При выполнении тела глобального модуля сам глобальный модуль 
  еще не полностью инициализирован, а если точнее, то его экспортируемые переменные, 
  процедуры и функции на данный момент еще не доступны извне самого глобального 
  модуля. И если в теле глобального модуля, например, с помощью функции ОткрытьФорму() 
  запустить какую-либо обработку, то данная обработка не сможет быть выполнена, 
  если в ней содержатся обращения к переменным, процедурам или функциям глобального 
  модуля.</p>
<p>Процедура ПриНачалеРаботыСистемы() вызывается после выполнения тела глобального 
  модуля. При вызове данной процедуры глобальный модуль уже полностью инициализирован 
  и доступен для обращения из других модулей. Поэтому в данной процедуре можно 
  выполнять действия запускающие другие модули, из которых осуществляется обращение 
  к объектам глобального модуля.</p>
<h2><a name="_Toc503983493">Точность вычисления и представления числовых величин</a></h2>
<b><i><br clear=all
style='page-break-before:always'>
</i></b> 
<h2><a name="_Toc503983494">Доступ во встроенном языке к метаданным</a></h2>
<p>В 1С:Предприятии 7.7 существует возможность обращаться к объектам метаданных 
  средствами встроенного языка. Эта возможность используется, прежде всего, для 
  создания универсальных алгоритмов, не зависящих от конфигурации и конкретных 
  объектов метаданных.</p>
<p>Весь доступ к метаданным осуществляется через объект &quot;Метаданные&quot; 
  и иерархию подчиненных ему объектов. Фактически объект &quot;Метаданные&quot; 
  является корнем иерархической системы объектов, которые во многом похожи на 
  дерево метаданных в конфигураторе.</p>
<p>В отличие от других средств встроенного языка доступ к метаданным не имеет 
  подробного описания в документации. Это объясняется тем, что названия атрибутов 
  и методов совпадают с терминами, выводимыми в текстовом представлении структуры 
  метаданных (меню &quot;Конфигурация – Описание структуры метаданных&quot;). 
  Соответственно для ознакомления с составом атрибутов и методов следует получить 
  текстовое представление и определить  в нем необходимые термины. Специфические 
  атрибуты и методы (не</p>
<p>отображаемые в текстовом представлении) отражены в документации и Синтакс-Помощнике.</p>
<p>Обращение к объектам метаданных выполняется с помощью методов вышестоящего 
  объекта. Название метода совпадает с названием типа объекта метаданных. В качестве 
  параметра может быть передан идентификатор искомого объекта или его номер. Если 
  объект найден, то возвращается собственно объект метаданных. Если объект не 
  найден то возвращается пустой объект метаданных. Для проверки того, возвращен 
  пустой объект или нет, следует использовать метод &quot;Выбран&quot;.</p>
<p><b>Например:</b></p>
<p>      Если Метаданные.Документ(&quot;Счет&quot;).Выбран()=0 Тогда</p>
<p>            Сообщить(&quot;В конфигурации нет документа Счет&quot;);</p>
<p>      КонецЕсли</p>
<p>Если параметр не задан, то возвращается количество объектов метаданных данного 
  типа.</p>
<p><b>Например:</b></p>
<p>      Сообщить(&quot;В конфигурации &quot;+Метаданные.Документ()+&quot; документов&quot;);</p>
<p>Эта возможность используется для обхода всех объектов метаданных</p>
<p>определенного типа.</p>
<p><b>Например:</b></p>
<p>      Для Инд=1 По Метаданные.Документ() Цикл</p>
<p>            Сообщить(&quot;Документ &quot;+Метаданные.Документ(Инд));</p>
<p>      КонецЦикла;</p>
<p>Для доступа к объектам метаданных, которые подчинены полученным объектам, также 
  соответственно используются методы, совпадающие с именами метаданных. Заметим, 
  что реквизит документа также является объектом метаданных (имеет идентификатор, 
  синоним и т.д.).</p>
<p><b>Например:</b></p>
<p>      Если</p>
<p>Метаданные.Документ(&quot;Счет&quot;).РеквизитШапки(&quot;Заказчик&quot;).Выбран()=0 
  Тогда</p>
<p>            Сообщить(&quot;В конфигурации нет реквизита Заказчик документа</p>
<p>Счет&quot;);</p>
<p>      КонецЕсли;</p>
<p>Для доступа к свойствам объектов метаданных используются атрибуты с соответствующими 
  именами.</p>
<p><b>Например:</b></p>
<p>      Сообщить(&quot;Тип номера расходного ордера:</p>
<p>&quot;+Метаданные.Документ(&quot;РасходныйОрдер&quot;).ТипНомера);</p>
<p>Таким образом, если ознакомиться с содержимым текстового представления метаданных, 
  то можно определить названия методов и атрибутов для доступа ко всем объектам 
  метаданных и их свойствам.</p>
<p>Некоторые свойства объектов метаданных являются ссылками на другие объекты. 
  В этом случае возвращается объект метаданных, к которому можно обращаться также 
  как и объектам, полученным с помощью методов объекта &quot;Метаданные&quot;.</p>
<p><b>Например:</b></p>
<p>      Сообщить(&quot;Длина кода справочника владельца справочника Договора:</p>
<p>&quot;+Метаданные.Справочник(&quot;Договора&quot;).Владелец.ДлинаКода);</p>
<p>Для некоторых объектов их свойства могут содержать несколько ссылок на различные 
  объекты метаданных. В этом случае к ним применяются методы &quot;Количество&quot; 
  и &quot;Получить&quot;.</p>
<p><b>Например:</b></p>
<p>      Сообщить(&quot;Количество ссылок в графе Сумма журнала Общий :&quot;     
</p>
<p>+Метаданные.Журнал(&quot;Общий&quot;).Графа(&quot;Сумма&quot;).Ссылки.Количество());</p>
<p>Заметим, что возвращаемые значения свойств объектов метаданных, соответствующие 
  одному из нескольких возможных вариантов, возвращаются в строковом виде в соответствии 
  с установленном для конфигурации языком (русским или английским). Возможные 
  значения в английском варианте можно посмотреть, сформировав текстовое описание 
  метаданных при установленном в конфигурации английском языке.</p>
<p>Следует учитывать, что механизм обращения к метаданным не связан непосредственно 
  с данными и не позволяет получать значения, хранящиеся в информационной базе 
  или значения агрегатных типов которые могут храниться в информационной базе. 
  Он предназначен только для получения информации о структуре метаданных. То есть 
  все объекты, получаемые через объект &quot;Метаданные&quot;, имеют специальный 
  тип &quot;Метаданные&quot;. Например, используя доступ к метаданным нельзя получить 
  значение типа &quot;Перечисление&quot;. То есть объект метаданных может сообщить 
  свойства перечисления, но не может выдать собственно значение типа &quot;Перечисления&quot; 
  чтобы присвоить его, например, реквизиту документа или сравнить с существующим 
  значением. Для получения собственно значения типа &quot;Перечисление&quot; необходимо 
  воспользоваться самим объектом &quot;Перечисление&quot;. Однако существует возможность 
  искать значение перечисления по идентификатору, полученному из метаданных.</p>
<p><b>Например:</b></p>
<p>      Для Инд=1 По Метаданные.Перечисление(&quot;ВидыПлатежа&quot;).Значение() 
  Цикл</p>
<p>            Сообщить(Перечисление.ВидыПлатежа.ЗначениеПоИдентификатору(</p>
<p>           </p>
<p>Метаданные.Перечисление(&quot;ВидыПлатежа&quot;).Значение(Инд).Идентификатор));</p>
<p>      КонецЦикла;</p>
<p>Объекты, используемые для доступа к метаданным, могут запоминаться в переменных 
  для сокращения в дальнейшем доступа к их свойствам и подчиненным объектам.</p>
<p><b>Например:</b></p>
<p>      МДСчет= Метаданные.Документ(&quot;Счет&quot;);</p>
<p>      Сообщить(&quot;Тип реквизита Заказчик документа Счет:</p>
<p>&quot;+МДСчет.РеквизитШапки(&quot;Заказчик&quot;).Тип);</p>
<p>Заметим, что объекты, используемые для доступа к метаданным, не могут сравниваться 
  между собой. Для того чтобы сравнить, например, два объекта метаданных одного 
  и того же типа на идентичность можно сравнить их идентификаторы.</p>
<h2><a name="_Toc503983495">Особенности работы с реквизитами неопределенного типа</a></h2>
<p>В 1С:Предприятии 7.7 существует возможность создавать в объектах метаданных 
  реквизиты неопределенного типа. Например,  эта возможность активно используется 
  для хранения в документе значений субконто связанных с некоторым счетом, по 
  которому должны формироваться проводки документом.</p>
<p>Особенность использования реквизитов неопределенного типа заключается в том, 
  что их значения нельзя присваивать, не назначив предварительно тип. Тип  назначается 
  с помощью метода &quot;НазначитьТип&quot; того объекта, которому принадлежит 
  реквизит. Таким образом, реквизиты неопределенного  типа отличаются от обычных 
  переменных  модулей, тип которых может свободно изменяться при присвоении значения.</p>
<p><b>Замечание!</b></p>
<blockquote>
  <p class="src">В модуле формы документа (аналогично и справочника) для назначения 
    типа реквизиту документа следует вызывать метод &quot;НазначитьТип&quot; у 
    самого документа (то есть не через точку, а непосредственно). Вызов метода 
    &quot;НазначитьТип&quot; для элемента управления (через объект Форма) следует 
    применять только к реквизитам диалога формы (не являющимися реквизитами документа).</p>
</blockquote>
<p>Следует учитывать, что реквизиты, имеющие неопределенный тип, не могут использоваться 
  для хранения строк длиннее 22 символов.</p>
<h2><a name="_Toc503983496">Особенности написания тела модуля</a></h2>
<p>При разработке модулей следует учитывать, что тело модуля (часть модуля, которая 
  располагается ниже всех процедур и функций) выполняется системой при инициализации 
  модуля. Эта особенность определяет некоторые ограничения на использование тела 
  модуля.</p>
<p>Фактически тело модуля служит только для инициализации переменных модуля объявленных 
  в его верхней части.</p>
<p>Для модуля формы в теле модуля не могут выполняться некоторые методы, которые 
  управляют элементами управления и свойствами формы. Все эти действия рекомендуется 
  выполнять в процедуре &quot;ПриОткрытии&quot;.</p>
<p>Для глобального модуля в теле модуля также могут не выполняться некоторые функции 
  встроенного языка. Например, в теле модуля не допускается открытие форм.</p>
<p>Для модуля документа если документ проводится из формы документа, то тело модуля 
  будет выполнено только один раз, хотя проведение может быть выполнено несколько 
  раз без закрытия формы. При групповом проведении тело модуля не будет выполняться 
  перед началом проведения каждого документа (групповое проведение документов 
  выполняется системой при переносе точки актуальности вперед и в режиме &quot;Проведение 
  документов&quot;). Таким образом, переменные, которые должны инициализироваться 
  при каждом проведении следует инициализировать в процедуре &quot;ОбработкаПроведения&quot;, 
  а не в теле модуля.</p>
</body>
</html>
